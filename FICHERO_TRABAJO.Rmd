---
title: "Fichero de trabajo Proyecto TD 2022"
author: Pere Caimari Fuster, Enrique Sayas Bailach,Lucas Contreras Vilar, Diego Martin
  Soler, Pablo Gómez Martínez, Natalia Pons Valdelvira
date: "`r Sys.Date()`"
output:
  # html_document:
  #   toc: yes
  #   toc_depth: '3'
  #   df_print: paged
  # html_notebook:
  #   echo: yes
  #   number_sections: yes
  #   toc: yes
  pdf_document:
    toc: yes
    toc_depth: 3
params:
  lang: ES
lang: r switch(params$lang, ES = 'es-ES', EN = 'en-US')
subtitle: Tratamiento de Datos. Grado en Ciencia de Datos- UV
language:
  label:
    fig: 'Figura '
    tab: 'Tabla '
    eq: 'Ecuación '
    thm: 'Teorema '
    lem: 'Lema '
    def: 'Definición '
    cor: 'Corolario '
    prp: 'Proposición '
    exm: 'Ejemplo '
    exr: 'Ejercicio '
    proof: 'Demostración. '
    remark: 'Nota: '
    solution: 'Solución. '
---


```{r setup, cache = F, echo = F, message = F, warning = F, tidy = F}


# CONFIGURACIÓN GENERAL
library(knitr)
options(width = 100)
rm(list=ls())

# Opciones generales de los chucks. Se utilizarán salvo cambios en el chunk
opts_chunk$set(echo=T, message = F, error = F, warning = F, comment = NA, fig.align = 'center', dpi = 200, tidy = F, cache.path = '.cache/', fig.path = './figura/')

# Opciones generales de dígitos cuando se incluyen tablas
#options(xtable.type = 'html')
knit_hooks$set(inline = function(x) {
  
  if(is.numeric(x)) {
    round(x, getOption('digits'))
  } else {
    paste(as.character(x), collapse = ', ')
  }
})
```

# Instalación automática de paquetes


```{r echo = F}

# Especificamos las librerías necesarias en esta lista

packages = c("tidyverse","knitr",'readr','lubridate','dplyr','tidyr', 'ggplot2', 'GGally', 'cat')

#use this function to check if each package is on the local machine
#if a package is installed, it will be loaded
#if any are not, the missing package(s) will be installed and loaded
package.check <- lapply(packages, FUN = function(x) {
  if (!require(x, character.only = TRUE)) {
    install.packages(x, dependencies = TRUE,repos='http://cran.rediris.es')
  }
  library(x, character.only = TRUE)
})

#verify they are loaded
search()

```


# Introducción del trabajo

El objetivo de esta *tarea/trabajo/práctica* es realizar un estudio sobre los diferentes niveles sonoros captados por algunos detectores de ruido situados en varias calles del barrio de Rufaza (Valencia). Para ello, hemos descargado los datos de la página "https://www.valencia.es/dadesobertes/es/data/?groups=medio-ambiente" de los detectores ubicados en las siguientes calles:

Sueca-Denia, Cádiz 3, Cádiz 16, Cuba 3, Sueca 2, Sueca 32, Sueca 61, Carles, Cervera-Chaflán Reina Doña María, Carles Cervera 34, José Serrano-Salvador Abril, Vivons-Cádiz, Puerto Rico 21, Doctor Serrano 21, General Prim-Chaflán Donoso Cortés



# Importación de los datos

Los ficheros ya están descargados en una carpeta llamada 'data'. A partir de la librería 'readr' los importaremos a nuestro entorno de trabajo. Además vamos a aprovechar este paso para añadirle a cada uno de los dataframe una columna llamada 'calle' que indique la calle de la que proviene cada obervación. Esto nos será muy útil más adelante


```{r}
library(readr)
cadiz3 <- read_csv("data/cadiz3.csv", col_types = cols
                   (dateObserved = col_date(format = "%Y-%m-%d")))
cadiz3 <- cadiz3 %>% mutate(calle = "cadiz3")
cadiz16 <- read_csv("data/cadiz16.csv", col_types = cols
                    (dateObserved = col_date(format = "%Y-%m-%d")))
cadiz16 <- cadiz16 %>% mutate(calle = "cadiz16")
carles34 <- read_csv("data/carles34.csv", col_types = cols
                     (dateObserved = col_date(format = "%Y-%m-%d")))
carles34 <- carles34 %>% mutate(calle = "carles34")
cuba3 <- read_csv("data/cuba3.csv", col_types = cols
                  (dateObserved = col_date(format = "%Y-%m-%d")))
cuba3 <- cuba3 %>% mutate(calle = "cuba3")
doctor_serrano <- read_csv("data/doctor_serrano.csv", col_types = cols
                           (dateObserved = col_date(format = "%Y-%m-%d")))
doctor_serrano <- doctor_serrano %>% mutate(calle = "doctor_serrano")
general_prim <- read_csv("data/general_prim.csv", col_types = cols
                         (dateObserved = col_date(format = "%Y-%m-%d")))
general_prim <- general_prim %>% mutate(calle = "general_prim")
maestro_jose <- read_csv("data/maestro_jose.csv", col_types = cols
                         (dateObserved = col_date(format = "%Y-%m-%d")))
maestro_jose <- maestro_jose %>% mutate(calle = "maestro_jose")
puerto21 <- read_csv("data/puerto21.csv", col_types = cols
                     (dateObserved = col_date(format = "%Y-%m-%d")))
puerto21 <- puerto21 %>% mutate(calle = "puerto21")
reina_maria <- read_csv("data/reina_maria.csv", col_types = cols
                        (dateObserved = col_date(format = "%Y-%m-%d")))
reina_maria <- reina_maria %>% mutate(calle = "reina_maria")
sueca2 <- read_csv("data/sueca2.csv", col_types = cols
                   (dateObserved = col_date(format = "%Y-%m-%d")))
sueca2 <- sueca2 %>% mutate(calle = "sueca2")
sueca32 <- read_csv("data/sueca32.csv", col_types = cols
                    (dateObserved = col_date(format = "%Y-%m-%d")))
sueca32 <- sueca32 %>% mutate(calle = "sueca32")
sueca61 <- read_csv("data/sueca61.csv", col_types = cols
                    (dateObserved = col_date(format = "%Y-%m-%d")))
sueca61 <- sueca61 %>% mutate(calle = "sueca61")
sueca_denia <- read_csv("data/sueca-denia.csv", col_types = cols
                        (dateObserved = col_date(format = "%Y-%m-%d")))
sueca_denia <- sueca_denia %>% mutate(calle = "sueca_denia")
vivons_cadiz <- read_csv("data/vivons_cadiz.csv", col_types = cols
                         (dateObserved = col_date(format = "%Y-%m-%d")))
vivons_cadiz <- vivons_cadiz %>% mutate(calle = "vivons_cadiz")


```

# Unión de los datos en un solo dataframe

Ahora vamos a usar la función bind_rows de la librería 'dplyr' para unir todos los data frames anteriores en uno solo. Esto es posible ya que todos poseen las mismas variables, por tanto, lo que estamos haciendo es unir las observaciones una debajo de otra

```{r}
library(dplyr)
sonido_tidy<-bind_rows(cadiz16, cadiz3, carles34, cuba3, 
                       doctor_serrano, general_prim, maestro_jose, 
                       puerto21, reina_maria, sueca_denia,sueca2, 
                       sueca32, sueca61, vivons_cadiz)

sonido_tidy <- sonido_tidy %>% select(6:12)
head(sonido_tidy)
tail(sonido_tidy)
```


# Tansformación a tidy dataset

## Cambiamos los nombres de las variables

Para poder entender mejor qué información contiene nuestros datos nos hemos fijado en la página web de origen y nos hemos dado cuenta de qué nos proporciona cada variable. Les cambiaremos los nombres para poder trabajar de forma más cómoda:

NSC <- Nivel sonoro continuo (LAeq)

7-19 <- Sonido desde las 7 hasta las 19 (LAeq_d)

SDTN <- Sonido día-tarde-noche, es utilizado para determinar la molestia vinculada a la exposición al ruido. (LAeq_den)

19-23 <- Sonido 19 hasta las 23 horas. (LAeq_e)

23-7 <- Sonido desde las 23 hasta las 7 horas. (LAeq_n)

Fecha <- Fecha de observación (dateObserved)

También haremos un primer resumen estadístico para ver una primera impresión acerca de los datos.


```{r}
variables <- c("NSC", "S7_19", "SDTN", "S19_23", "S23_7",  "Fecha", "CALLE")
names(sonido_tidy) <- variables
summary(sonido_tidy)
```

Como podemos obervar no se encuentran valores perdidos en ninguna variable. Tenemos 5 variables de tipo numérico, una de tipo carácter (que se debe transformar a factor) y otra desconocida (que es de tipo fecha). Estas dos últimas se deben corregir.

## Categoría de las variables

Vamos a cambiar el tipo de variables de Fecha y Calle, La primera será de tipo fecha y la segunda de tipo factor, con tantos niveles como calles tenemos.

```{r}
sonido_tidy$Fecha <- ymd(sonido_tidy$Fecha)
sonido_tidy$CALLE <- as.factor(sonido_tidy$CALLE)
class(sonido_tidy$Fecha)
class(sonido_tidy$CALLE)
```


## Imputación de los datos

En la observación del summary hemos observado que los datos contienen algunas inconsistencias como es el hecho de que aparecen valores infinitos. Para solucionar este problema y que los estadísticos que realizaremos a posteriori tengan un valor más próximo al real, realizaremos una imputación cambiando el valor inf por el máximo de esa calle para variable.

```{r}
sonido_tidy%>% filter(S19_23 == Inf|S7_19 == Inf) 
```

Ahora como podemos observar los problemas se encuentran en las calles cadiz16 y maestro jose, procedemos a la imputación.

```{r}
maximo <- sonido_tidy %>%
  filter(CALLE == 'cadiz16'& S19_23 != Inf) %>%
  select(S19_23) %>% max()
sonido_tidy$S19_23[sonido_tidy$S19_23==Inf] <- maximo
maximo <- sonido_tidy%>%
  filter(CALLE == 'maestro_jose'& S7_19 != Inf) %>%
  select(S7_19) %>% max()
sonido_tidy$S7_19[sonido_tidy$S7_19==Inf] <- maximo
```

# Análisis exploratorio de los datos

En este apartado vamos a estudiar la estructura interna de los datos.


Vamos a empezar analizando cada una de las variables sonoras en cada calle para ver sobre qué valores se mueve cada una.
```{r}
t1 <- sonido_tidy %>%
  pivot_longer(names_to = "sonido", values_to = "valor", NSC:S23_7)

ggplot(t1, aes(x = CALLE, y = valor, col = CALLE)) + geom_boxplot() + 
  theme(axis.text.x = element_blank(), axis.ticks = element_blank()) +
  facet_wrap(~sonido)

```
Podemos afirmar que los datos están bastante distribuidos. La regla del boxplot determinaría muchos outliers pero estos no deben considerarse como outliers ya que son valores posibles definidos en un intervalo razonable.

Ahora analizaremos si las variables siguen una distribución gaussiana. Para ello vamos a utilizar diferentes tipos de gráficos
```{r}
sonido_tidy %>% select(S7_19,S19_23,S23_7) %>%
  pivot_longer(names_to = 'horas', values_to = 'sonido',S7_19:S23_7) %>%
  group_by(horas) %>%  ggplot(aes(x = sonido)) +
  geom_histogram(fill = "aquamarine", colour = "darkblue", size = .3) +
  scale_y_continuous( name = "Num. Oservaciones" ) +
  scale_x_continuous( name = "Sonido" ) +
  facet_wrap(~horas)

qqPlot(sonido_tidy$S7_19)
qqPlot(sonido_tidy$S19_23)
qqPlot(sonido_tidy$S23_7)

```
Como podemos ver, los datos acerca de las variables sobre las horas no siguen una distribución gaussiana debido a la alta frecuencia de los valores elevados. 

Análisis bivariante
```{r}
sonido_tidy %>% select(NSC:S23_7) %>% ggpairs()

s1 <- sonido_tidy %>% select(NSC:S23_7)
cor(s1, method = "spearman")
cor(s1, method = "pearson")

```


# Creación de los estadisticos 

```{r}
tabla <- sonido_tidy %>% select(NSC:S23_7)  %>%
  pivot_longer(names_to =  'tipo',values_to= 'sonido',NSC:S23_7) %>%
  group_by(tipo) %>% 
  summarise_at(vars(sonido),
               list(min=min, max=max, med=mean , mediana=median,sd=sd))
tabla 

```

# Preguntas a resolver

Una vez ya hemos hecho un primer análisis de los datos, sabemos cómo están organizados y distribuidos. Debemos plantearnos las preguntas que queramos resolver.
-¿Cuál es la calle más/menos ruidosa?
```{r}
sonido_tidy %>% group_by(CALLE) %>%
  summarise(Nivel_sonoro_continuo_medio_maximo = mean(NSC)) %>%
  filter(Nivel_sonoro_continuo_medio_maximo ==
           max(Nivel_sonoro_continuo_medio_maximo))

sonido_tidy %>% group_by(CALLE) %>%
  summarise(Nivel_sonoro_continuo_medio_minimo = mean(NSC)) %>%
  filter(Nivel_sonoro_continuo_medio_minimo ==
           min(Nivel_sonoro_continuo_medio_minimo))
```
-¿Cuál es la calle que ha alcanzado el máximo/mínimo nivel de ruido?
```{r}
sonido_tidy %>%
  group_by(CALLE) %>%
  summarise(Nivel_sonoro_continuo_maximo = max(NSC)) %>%
  filter(Nivel_sonoro_continuo_maximo ==
           max(Nivel_sonoro_continuo_maximo))

sonido_tidy %>%
  group_by(CALLE) %>%
  summarise(Nivel_sonoro_continuo_minimo = min(NSC)) %>%
  filter(Nivel_sonoro_continuo_minimo == 
           min(Nivel_sonoro_continuo_minimo))
```

-¿Cuáles son las horas en las que hay más/menos ruido?
```{r}
sonido_tidy %>%
  gather(key = "horario", value = "nivel_sonido", c(S7_19,S19_23,S23_7)) %>%
  group_by(horario) %>%
  summarise(Nivel_sonoro_continuo_medio_maximo = mean(nivel_sonido)) %>%
  filter(Nivel_sonoro_continuo_medio_maximo ==
           max(Nivel_sonoro_continuo_medio_maximo))

sonido_tidy %>%
  gather(key = "horario", value = "nivel_sonido", c(S7_19,S19_23,S23_7)) %>%
  group_by(horario) %>%
  summarise(Nivel_sonoro_continuo_medio_minimo = mean(nivel_sonido)) %>%
  filter(Nivel_sonoro_continuo_medio_minimo ==
           min(Nivel_sonoro_continuo_medio_minimo))
```

-¿De qué forma aumenta el ruido durante los días festivos (Navidades, Fallas, etc)?
```{r}
navidad <- sonido_tidy %>%
  select(Fecha) %>%
  filter((month(Fecha) == 12 & day(Fecha) >= 24) |
           (month(Fecha) == 1 & day(Fecha) <= 7))
fallas <- sonido_tidy %>%
  select(Fecha) %>%
  filter((year(Fecha) != 2021 & month(Fecha) == 3 &
            day(Fecha) >= 1 & day(Fecha) <= 22 ) |
           (year(Fecha) == 2021 & month(Fecha) == 9 &
              (day(Fecha) >= 1 | day(Fecha) <= 5)))
sonido_tidy_festividad <- sonido_tidy %>%
  mutate(festividad = c(rep(NA,nrow(sonido_tidy))))

for (i in 1:nrow(sonido_tidy)){
  if (sonido_tidy$Fecha[i] %in% navidad$Fecha){
    sonido_tidy_festividad$festividad[i] <- "navidad"
  } else if(sonido_tidy$Fecha[i] %in% fallas$Fecha){
    sonido_tidy_festividad$festividad[i] <- "fallas"
  }
  else{
    sonido_tidy_festividad$festividad[i] <- "ordinario"
  }
}
calles <- c("cadiz16", "cadiz3", "carles34", "cuba3",
            "doctor_serrano", "general_prim", "maestro_jose",
            "puerto21","reina_maria", "sueca_denia","sueca2",
            "sueca32", "sueca61", "vivons_cadiz")

ggplot(sonido_tidy_festividad, aes(x = Fecha, y = NSC, col = festividad)) +
  geom_line(aes(xend = lead(Fecha), yend = lead(NSC))) +
  facet_wrap(~CALLE) + theme(axis.text.x = element_blank(),
                             axis.ticks = element_blank())

# for (j in calles){
#   grafico <- sonido_tidy_festividad %>% filter(CALLE == j) %>% ggplot(aes(x = Fecha, y = NSC, color = festividad)) + geom_segment(aes(xend = lead(Fecha), yend = lead(NSC))) + ggtitle(j)
#   print(grafico)
# }
```

